var ng = require('nimblegecko'),
    CATEGORY_ME = 'me',
    CATEGORY_LINK = 'link',
    CATEGORY_TEXT = 'text',
    CATEGORIES = [
        CATEGORY_ME,
        CATEGORY_LINK,
        CATEGORY_TEXT
    ]
  , _ = require('underscore')


function formatLinks(text) {
    var r = new RegExp("((?:https?|ftp)://[^\\s]*)", "gi")
    return text.replace(r, '<a href="$1" target="_blank">$1</a>')
}


function escapeText(text) {
    return formatLinks(text.replace('<', '&lt;').replace('>', '&gt'))
}

//
// Sometimes tweets, containing re-tweets are cut off
// due to the inclusion of the name of original author.
// In this case original message is included in retweeted_status.text
//
// This function returns either text of message if it's not cut off,
// otherwise - 'restored' text of the original message + RT @name.
//
function getTweetText(tweet) {
    //
    // .retweeted_status.text:
    //      "oh BURN... RT @HuffPostPol: Obama fires back at critics: 'Ask Osama bin Laden' if I engage in 'appeasement'. http://t.co/3ZZiBN5q"
    // .text:
    //      "RT @courteneyh: oh BURN... RT @HuffPostPol: Obama fires back at critics: 'Ask Osama bin Laden' if I engage in 'appeasement'. http://t.co ..."
    //
    var text

    if (tweet.truncated) {

        var origText = tweet.retweeted_status.text
          , halfText = origText.substring(0, origText.length / 2)
          , startPos = tweet.text.indexOf(halfText)

        if (startPos === -1) {
            // something went wrong, just return the cut off text
            text = tweet.text
        } else {
            text = tweet.text.substring(0, startPos) + origText
        }

    } else {
        text = tweet.text
    }

    return escapeText(text)
}


function getEmptyCollection() {
    var res = {},
        i = CATEGORIES.length

    for(;i--;) {
        res[CATEGORIES[i]] = []
        res[CATEGORIES[i]].unread_count = 0
    }

    return res
}


function getTagForTweet(tweet, user) {

    //
    // Categories
    //
    //  1. Replies to @user / @user being mentioned
    //  2. links
    //  3. plain text
    //

    var text = tweet.escaped_text,
        str_regex_reply = '^\\@' + user.screen_name + '.*',
        regexReply = new RegExp(str_regex_reply, 'gi'),
        regexMention = new RegExp('^.+\\@' + user.screen_name + '.*', 'gi'),
        regexLink = new RegExp('((?:https?|ftp)://[^\\s]*)', 'gi'),
        isReply = regexReply.test(text),
        isMention = regexMention.test(text),
        isFromMe = tweet.user.id_str === user.user_id
        isMe = isReply || isMention || isFromMe,
        isLink = regexLink.test(text),
        isPlainText = !isReply && !isMention && !isLink

    if (isMe) {
        return CATEGORY_ME
    }

    if (isLink) {
        return CATEGORY_LINK
    }

    if (isPlainText) {
        return CATEGORY_TEXT
    }
}


function sortTweets(args) {

    ng.utils.checkRequiredOptions(args, ['tweets', 'user'])

    var sorted_tweets = getEmptyCollection()
      , length = args.tweets.length
      , i = 0
      , tweet

    for (; i < length; i++) {

        tweet = args.tweets[i]
        tweet.escaped_text = getTweetText(tweet)
        tag = getTagForTweet(tweet, args.user)

        delete tweet.text

        sorted_tweets[tag].push(tweet)
        if (tweet.is_read === false) {
            sorted_tweets[tag].unread_count += 1
        }
    }

    return sorted_tweets
}

exports.sortTweets = sortTweets
exports.CATEGORIES = CATEGORIES
exports.CATEGORY_ME = CATEGORY_ME
